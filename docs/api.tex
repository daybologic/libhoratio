% Daybo Logic C RTL Memory Manager
% Copyright (c) 2000-2014, David Duncan Ross Palmer, Daybo Logic
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%     * Redistributions of source code must retain the above copyright notice,
%       this list of conditions and the following disclaimer.
%
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%
%     * Neither the name of the Daybo Logic nor the names of its contributors
%       may be used to endorse or promote products derived from this software
%       without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.

\documentclass{article}
\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}
\usepackage{hyperref}
\begin{document}
\title{libhoratio \input{.version}Programmers' Guide}\author{Daybo Logic}
\maketitle

% This is the changeset of the repository, generated by Makefile.
% It only exists if you have Mercurial installed.
% If you do not have a Mercurial checkout, or hg is not installed, it
% contains a username@hostname combination, so that we know that the
% documentation is not official.
\par\vspace*{\fill}
\begin{center}
\input{.ident}
\end{center}

\newpage
\par \textbf{\underline{Contents}}
\\
\href{#About}{1.~ About the library}
\\
\href{#Who}{1.1~ So who are Daybo Logic?}
\\
\href{#Contact}{1.2~ Contacting the author}
\\
\href{#FAQ}{1.3~ FAQ}
\\
\href{#Compile}{1.4~ Compiling the sources}
\\
\href{#Config}{1.5~ Configuration options explained}

\par \href{#Enumerations}{2.0~ Enumerations and detail}\\
\href{#Cost}{2.1~ How much does it cost?}
\\
\href{#Platforms}{2.2~ What platforms is the library available
for?}

\par \href{#Concepts}{3.0~ Concepts and structures used by the
library}
\\
\href{#Starting}{3.1~ Getting started}
\\
\href{#Portability}{3.2~ Portability issues}
\\
\href{#8086}{3.3~ 8086 builds}
\\
\href{#PCH}{3.4~ Precompiled headers}

\href{#Plans}{4.0~ Plans for next version}

\par \href{#Listings}{5.0~ Function listings}\\
\href{#FuncDescs}{5.1~ Descriptions of all functions and their use}

\newpage
\textbf{1.~ About the library}
\\
Horatio is designed to be used as an alternative to
\\
memory tracking tools such as CodeGuard of MemorySleuth.  A selection of key features follows.
\\
However, memory over-run support is not yet supported. TODO Put this is a future features section
\\
Swapping is not implemented but may be in a future version.\\
If the program is going to be released even though
\\
it contains memory bugs, the traps can be turned off or passed to
a handler which will only execute the serious ones.
\\
\begin{itemize}
\item Thread safety
% TODO Document support threaded abstractions
\item Memory usage and leak reports, supporting several database back-ends
% TODO Document the back-ends
\item Optional verbose log
% TODO Need to allow the user to rename this log
\item Optional garbage collection mode
% TODO Need to document that traps be turned off for this
\item Memory blocks may be managed by separate master descriptors
\item API allows interrogation of block information before it is used, include validity, block size and flags
\item Block locking allows traps in case memory is resized or freed prematurely
\item Common pointer mistakes such as releasing unowned memory are eliminated
\item Hooking of almost all operations so the program may preview activity, extend the logging framework, or trigger periodic jobs
% TODO explain thread locking limitations elsewhere
\item Re-build to allow more hooks per-event, default=32
\item Re-build to allow more descriptors per program, default=512
\item The library does not limit the number of blocks which can be allocated
\item Source level tracing Information for every block allocated
\end{itemize}
\textbf{1.1~ So who are Daybo Logic?}
\\
Daybo Logic started in 1997 as a software development company.~ It
then became a general troubleshooting company, as a sole trader, David
Duncan Ross Palmer and in 2006, it reverted to being purely a
programming hobby of mine.~ I still release all my software,
including source code on the Daybo Logic web-site at \href{http://www.daybologic.co.uk/}{www.daybologic.co.uk}.\\
and additionally, on the code-hosting service, operated by Atlassian
\href{https://bitbucket.org/daybologic}{bitbucket.org/daybologic}.\\
\\
\textbf{1.2~ Contacting the author}
\\
The author of this library is David Duncan Ross Palmer, a C/C++
programmer
since 1997 and a BASIC programmer since 1989.~ Born 5th March 1982
and interested in computers since an early age.~ This product was
a side effect of wanting to be able trap memory errors on users
machines
during beta testing phase, it was not originally designed to be
released,
it was originally too dependant on other Daybo Logic internal
libraries.~
It was then offered for download for free and a fee for the advanced
features.~
Eventually the whole source was open sourced under the GNU General
Public
License.~ IN 2006, the library was re-released under a BSD-style
license.~ The author of the library can be contacted by visiting
the following web-site: \href{http://www.daybologic.co.uk/mailddrp/}{\url{http://www.daybologic.co.uk/mailddrp/}}.~
I especially welcome bug reports, feature requests and technical
questions.\\
\\
\textbf{1.3~ FAQ}
\\
Frequently Asked Questions and common
compile problems
\par Q - I am using ./configure -$\,$-enable-threads -$\,$-with-gnu-pth to link
with the GNU Portable Threads library.~ As soon as my program
initialises the Horatio library, the program crashes with a
segmentation fault.~ Is this a bug?\\
A - No, GNU Portable Threads needs explicit initialisation before
use.~ Horatio uses GNU Portable threads for an internal lock and
initialises this lock when Horatio is initialised.~ It is your
program's responsibility to initialise GNU Portable Threads before
Horatio is initialised.~ You will need to call pth\_init( ) at
some point before \href{#Startup}{horatio\_Startup}( ) is called.\\

\par Q - Error horatio.h (line number): Declaration missing ;
\\
A - The following answer applies to 16-bit segmented programming
only.~ This only happens if you selected to have explicit far data
for the 16-bit tiny, small
or medium memory models.~ The answer is one of these solutions I
hope,
firstly check the language is set to non-ANSI compliance, if your
compiler
only supports ANSI you cannot support explicit far pointers so give
up!~
The other problem is on line 112 (ish) of hbuild.h \#define
DPCRTLMM\_FARDATA
\_ \_ far, change the \_ \_ far bit to just far and try again.~ Look
for
what the 'far' keyword equivalent is in your language.~ If you
still
have problems contact me.

\par Q - No prototype for function 'farmalloc' or 'farcalloc' or
'farfree'
or 'farrealloc'
\\
A - The following answer applies to 16-bit segmented programming
only.~ The explicit fars are non-ANSI, unfortunately the functions
differ
from one compiler to the next when one strays from ANSI.~ In
hbuild.h
there are a list of functions here, change them to point to your
compiler's
equivalent functions if you can discover what they are.~ If you
don't
have any you will have to give up and turn off this option, make sure
you
don't have strict ANSI C compliance on or anything first but if all
else
fails just compile for the compact/large or huge model.

\par Q - I want to compile for 16-bit x86 processors in small memory
models.~ However, the pointers returned from Horatio use my
segment address and not real segment address,~ When I try to
success these pointers, the program crashes, or unexpected results
happen.\\
A - The library only functions correctly with far data, run ./configure
with -$\,$-enable-fardata to enable explicit support.~ Unfortunately,
this is not within the scope of ANSI C and you may find difficulty
compiling.~ If your compiler cannot support explicit far pointers,
you may be forced to compile for another memory model or not use
Horatio at all.\\

\par Q - My program is crashing unexpectedly when I try to free blocks of
memory (or earlier while using the memory manager)
\\
A - The most common problem is forgetting to start the library, if
this is not the case and you are compiling for a 16-bit processor it
may
be that the data is near.~ The easiest way to avoid this is to
rebuild
in a memory model which has far data.~ There is another way in
this
version of the library, Configure with -$\,$-enable-fardata.~ If this
does not solve
the problem please send me all details possible.
\\
\textbf{1.4~ Compiling the sources}
\\
The way in which the library is
built can change from time to time,
last minute notes may be added in a file called README if these do not
work.\\
Compiling under UNIX:\\
\\
Unpack the source tarball with the
following command:\\
tar -zxvf horatio-FIXME.tar.gz or\\
tar -jxvf horatio-FIXME.tar.bz2
if you are using the bzip2ed version.\\
\\
cd horatio-FIXME/\\
./configure -$\,$-help\\
\\
This will display a large output
of help text.~ It may help to
pipe this though 'more'.~ Read this help carefully and when you
have decided upon the configuration options you want to use, type:\\
./configure [add any options you
want to use here]\\
Once the script has configured
(assuming all went well), type:\\
make.\\
This builds the library.\\
You can now type make check if you
want to build and run some
example/test programs.\\
Finally, as root, type make
install.\\
The Horatio library is now
installed and ready for use by your system.\\
\\
Compiling under Win32 (Borland C):\\
FIXME: (write these instructions)\\
\\
Compiling under Win32 (Microsoft C):\\
FIXME: (write these instructions)\\
\\
Compiling under Win32 (Open Watcom C):\\
FIXME: (write these instructions)\\
\\
Compiling under DOS (Turbo C):\\
First, you will need to have
either a Win32 or UNIX-like box available and have Perl
installed.~ Then run perl ./utils/mkdosdist.pl\\
This will update all of the of the source files in a sub-directory
called dos\_dist/ and rename them to DOS compatible names.\\
Finally, it will process each of the files multiple times to rename any
internal references to the old filenames (this may take some time).\\
Warning: Do not run the mkdosdist.pl script if you have built the
sources under another OS because you will have your own\\
config.h which will over-write the DOS-crafted one which is stored as
dos\_dist/config.h.\\
You now have a usable source for building with Turbo C.~ I have
also supplied project files which may or may not work for you.\\
I built them from the directory c:$\backslash$horatio.~ If it works, you
might be able to get away with typing:\\
tc /b horatio.prj\\
This will build horatio.lib from the sources.~ You may need to
mess around with memory models and the contents of config.h\\
to get things to work.~ I found that things generally worked only
if built with a large memory model.~ This is generally what you\\
will need to do nowadays anyway, as people don't tend to explicitly use
far or near pointers any more.\\
TODO: This DOS support all needs updating because of the library re-branding to Horatio\\
\\
\textbf{1.5~ Configuration options explained}
\\
Since version 1.2.0, the old config program has been removed.~ It
has been replaced with a GNU autoconf generated configure script.~
This is good news for the portability and maintenance of Horatio on
UNIX platforms but it does means that pure DOS and Win32 users must
either run the script via Cygwin (Win32) only, or edit config.h
manually and then build their own makefile for their compiler.~
However, I have decided that it is in the best interest of the project
because, although we do have DOS and Win32 users, the majority of the
library's users use a form of UNIX and UNIX is my development platform
for the library.\\
./configure -$\,$-help displays some help but if you're still stuck, these
explanations
should reveal some more detail and history.
\par -$\,$-enable-win32\\
The configure script can't tell if you are running it under Cygwin and
indeed, you may still want to build for POSIX.~ Enabling this
switch turns on specific Win32 code.~ If you are building with
-$\,$-enable-threads, it will use the Win32 API for mutual exclusion,
rather than the pthread (POSIX threads) API.\\

\par -$\,$-enable-debug
\\
This option defines DEBUG, it means extra debugging code is added to
Horatio for when it is being debugged, it does not add any extra
information
for debugging your programs, only to the codebase.~ This could cause
the
library to abort on assert( ) traps and such.~ If you want to help
submit problems with Horatio, make sure it's built with
-$\,$-enable-debug.~
This will also add symbolic debug information to Horatio where
possible.\\

\par -$\,$-enable-threads
\\
Enables multi-thread safety.~ Note: This does not imply support,
Horatio can't handle threads portably for logging purposes etc.~
This option makes sure that Horatio is mutually exclusive, that is, if
two threads attempt to call the library at the same time, one will
succeed
and one will have to wait until the first finishes.~ This stops
internal
corruption of Horatio's data structures but adds overhead, don't use
it
if you don't use pre-emptive threads.~ This is supported only on
the
following platforms: POSIX, Win32.\\

\par -$\,$-with-gnu-pth\\
This will enable you to build against the GNU Portable Threads library,
rather than the POSIX threads API.~ This is useful if your program
uses the GNU Portable Threads rather than POSIX threads.~ You will
get a warning if you specify -$\,$-enable-win32 and -$\,$-with-gnu-pth because
at time of writing, The GNU Portable Threads are only supported on
UNIX-like platforms.~ Your program is responsible for initialising
the GNU Portable Threads library before Horatio is started.\\

\par -$\,$-enable-stderr
\\
Error traffic will be printed onto stderr, a stream which can be
redirected separately from the normal standard output stream.\\

\par -$\,$-with-hook-chain-size:nnnn
\\
The default hook chain size is 32.~ In Horatio before it was
Open-sourced advanced debug hooks were only supported in commercial
versions.~
to get rid of them set this to zero.~ Otherwise a debug matrix is
used, a matrix of chains of hooks.~ Callers may install hooks into
the matrix, up to nnnn hook per hooktype.~ For example, if
monitoring
allocation requests, only 32 (by default) hooks may be installed for
the
allocation type of hook.~ If one does not plan to use this
feature,
set this to zero to avoid space wastage.~ Being a matrix, a high
value will occupy a large amount of space quickly.~ The total size
used can be calculated by the hook chain size, multiplied by the size of
a hook pointer, multiplied by the number of debuggable hook types (eg.
allocation is one specific type of debug hook).\\

\par -$\,$-with-safety-list-size:nnnn
\\
The default is 512.~ When creating new block arrays, each address
of a block array is stored in an internal "safety list".~ It's a
fixed
size array determined here.~ It may not be zero but may be in the
future.~ I recommend a new block array per module, so if the
program
contains 512 modules this is fine, otherwise adjust accordingly to save
space or provide more space.

\par -$\,$-enable-fardata
\\
For tiny, small and compact memory models in 16-bit segmented systems
ONLY.~ This makes sure pointers are not truncated between callers
in modules using near pointers and the Horatio library in other
modules
using near pointers.~ This ensures the Horatio library explicitly
uses far pointers and the host program's code knows it.~ Far
pointers are non-ANSI, therefore, if this doesn't work,
editing build.h might be necessary, see the \href{#FAQ}{FAQ}.~
If you enable this option on 32 or 64-bit platforms, you will just
break the build.\\

\par -$\,$-enable-hdrstop\\
This will produce \#pragma hdrstop and allow pre-defined header
stop-points for pre-processors which support it.~ It is harmless
and will just produce a warning for every file if it is not supported.\\

\par -$\,$-with-no-null-array\\
When I created the new NULL (default) array so that calls could be
made to \href{#Alloc}{horatio\_Alloc}( ) and other functions
without
specifying a block array, I realised that existing code might be broken
if it accidentally failed to created a new block array and then used
it.~
Therefore I have always kept up an effort to make sure that the new
NULL
array could be ignored and cause the same errors as before.~ This
really is for legacy support only.\\

\par -$\,$-enable-log
\\
A file called HORATIO.LOG will be created and record the activity of
every library call.~ This is an alternative to installing debug
hooks.~ Do not forget to disable this feature before releasing
your program!~ HORATIO.LOG can grow very quickly!\\
FIXME: What is this log called after the re-branding?
\\
\textbf{2.0~ Enumerations and detail}\\
Blah\\
\\
\textbf{2.1~ How much does it cost?}
\\
Nothing, but I do accept donations via the web-site.~ If you have
found this software useful, please donate.~ If you can't afford to
donate (which I wholly understand), please send me an email letting me
know what you are using the library with.~ I really would be
interested to know!~ I get quite a bit of email but I do enjoy
reading email from folk who are using my software.\\
\\
\textbf{2.2~ What platforms is the library available for}
\\
The library has been tested on the following platforms: Win16, Win32,
DOS (16-bit and 32-bit builds), Debian GNU/Linux, Raspian and FreeBSD.\\
I aim to make sure this library can be built anywhere and if you have
any specific problems building it, please let me know.\\
\\
\textbf{3.0~ Concepts and structures used by the library}
\\
The primary memory management structure is called a block descriptor,
it contains basic information about a block of memory allocated by the
program, it is not normally directly accessed by a program, it is
generally
only used by the library, it is possible to access it but I don't know
why a program would need to because all information may be obtained
using
the library interface.
\par These block descriptors contain this simple information: The block's
base address, size in bytes and a number of flags with special
meanings.

\par The other structure you will encounter is the block descriptor
array.~
I recommend that every C file maintains it's own array.~ When a
block
is allocated it's descriptor is always inserted into one of these arrays
and nearly every library call will want to know the address of one of
these
arrays.~ This only causes a problem if the program~ passes a
descriptor to another module the program which tries to get size
information
on the block using the library functions while passing it's own array,
then the program will be terminated because the library will assume
that
the address is invalid.~ I recommend using NULL as a placeholder
for
arrays, for blocks which are designed to be shared.~ Normal
sharing
is fine, as long as the library is not used on that block from another
module.~ Note: If you have configured the library
-$\,$-with-no-null-arrays,~ it will not be possible to use NULL in
this manner.\\

\par The final structure is stored internally and the program should
never
need to access, this structure is called the safety list.~ It is a
large fixed size array of all the addresses of the block descriptor
arrays
used throughout the program.~ The interface to this list is kept
internal
to the library, if you want to access it you could always add it to
horatio.h,
although there should be no reason to do this.~ The safety list's
size can be adjusted at configuration time via the
-$\,$-with-safety-list-size option.\\

\par So what is this safety list for if I can't access it under normal
circumstances?~
Well, it's used to trap any call to the library which specifies an
invalid
pointer to a block descriptor array.~ It is also processed when
the
library is shut down to ensure all blocks have been released, it is
therefore
is the primary structure for producing a leak report.
\\
\textbf{3.1~ Getting started}
\\
If you already have a program to convert to use the library I suggest
this.~ Download at least version 1.1.4 and define USING\_HORATIO
before
including horatio.h in each module.~ This makes malloc( ),
calloc( ), realloc( ) and free( ), call Horatio instead.~ Also,
since the library should
be started and shutdown correctly, I recommend code similar to example3
as a typical transparent usage program.
\par If you are writing a new program use the library from the start, add
a block descriptor array structure to the main module at file level,
then
in main call the library startup routine, create the array then
allocate
blocks using it.~ When main() is about to exit free all blocks,
destroy
the array with the dedicated function and shutdown the library.~
These
destroy and shutdown routines are the main ones which check if anything
was not freed from the array.\\
\\
\textbf{3.2~ Portablilty issues}
\\
This library will slow the program down but not make it any less
portable
as such.~ However if you later want to speed the program up and
remove
the library read the section Getting Started, the first paragraph
describes
a hack, designing the program in the first place to use this hack is
the
only way to easily remove the library.~ Another approach might be
to write a dummy version of the library, only doing the bare minimum, I
intend to write one of these at some point soon.
\par By default the library source is portable, it can be setup to use
some
non-ANSI features:
\\
far pointers, mutexes and critical sections.~
Most instructions for changes are in build.h, please use the configure
script
where appropriate.\\
\\
\textbf{3.3~ 8086 builds}
\\
When building the library for the 8086-80286 (16-bit versions of
Intel's
processor) the library should be built for one of these memory models:
Compact, Large or Huge.~ Trying to build the library for smaller
memory
models results in near data.~ If such a build is made I have
discovered
that the hosting program will be assuming the wrong data segment when
the
pointers are returned from the library.~ There is a way to get
around
this if you really want to use a smaller memory model, build with
-$\,$-enable-fardata.~ This is non-ANSI and you're on your own if your
compiler can't support the '\_\_far' keyword.\\
\\
\textbf{3.4~ Precompiled headers}
\\
My compiler (Borland C++) supports this pragma:
\\
\#pragma hdrstop
\\
However using it on other compilers might cause a warning, to avoid
annoyance to people, it is disabled by default.~ To enable it,
re-configure with ./configure -$\,$-enable-hdrstop.\\
\\
\textbf{4.0~ Plans for next version}

\par The internal debug hook executive seems to use a parameter which it
could get from the debug info structure passed to it, the hook type is
not used and is a waste.~ This does not affect callers of the
library,
since the debug hook executive cannot be called from outside.
\\

\par Swapping to disk should be implemented with an LRU algorithm, based
on the flag in block descriptor (unswappable, bit 1) and the block
descriptor
may have to be extended with more fields to support this.
\\

\par The library is a bit slow due to an excessive amount of calls to
\_VerifyPtrs(
), which an internal routine called to check the user's pointers are
valid,
however it's also called when functions call other functions, even
though
they already know the pointers are safe, to avoid this I may make an
inner
shell, where the user calls safety wrappers around the real library and
all functions call the inner shell functions and not the entry points
the
users sees.
\\

\par Memory over-run support
\\

\par Swapping is not implemented but may be in a future version.
If the program is going to be released even though
\\

\par it contains memory bugs, the traps can be turned off or passed to
a handler which will only execute the serious ones.
\\
\\
\textbf{5.0 Function listings}
\\
No documentation is supplied or can be found that I have written for
the hidden functions which I believe it is not worth library users
trying
to access.~ The file horatio.H contains most structures that will
be of any interest too.~ If you have the library source you can
read
all the other headers to discover the hidden interface if you are that
nosey.
\par \href{#InstallDebugHook}{horatio\_InstallDebugHook( )}
\\
\href{#GetDebugHookChainCount}{horatio\_GetDebugHookChainCount(
)}
\\
\href{#GetDebugHookMatrixCount}{horatio\_GetDebugHookMatrixCount(
)}
\\
\href{#UninstallDebugHook}{horatio\_UninstallDebugHook( )}
\\
\href{#Alloc}{horatio\_Alloc( )}
\\
\href{#Free}{horatio\_Free( )}
\\
\href{#CreateBlockArray}{horatio\_CreateBlockArray( )}
\\
\href{#DestroyBlockArray}{horatio\_DestroyBlockArray( )}
\\
\href{#IsDefaultBlockArray}{horatio\_IsDefaultBlockArray( )}
\\
\href{#Startup}{horatio\_Startup( )}
\\
\href{#Shutdown}{horatio\_Shutdown( )}
\\
\href{#IsStarted}{horatio\_IsStarted( )}
\\
\href{#GetBlockSize}{horatio\_GetBlockSize( )}
\\
\href{#IsBasBlockPtr}{horatio\_IsBadBlockPtr( )}
\\
\href{#IsBadArrayPtr}{horatio\_IsBadArrayPtr( )}
\\
\href{#Realloc}{horatio\_Realloc( )}
\\
\href{#Calloc}{horatio\_Calloc( )}
\\
\href{#InstallTrapCallback}{horatio\_InstallTrapCallback( )}
\\
\href{#RemoveTrapCallback}{horatio\_RemoveTrapCallback( )}
\\
\href{#GetTrapCallbackInfo}{horatio\_GetTrapCallbackInfo( )}
\\
\href{#ModifyDescriptorFlags}{horatio\_ModifyDescriptorFlags( )}
\\
\href{#SetBlockLockingFlag}{horatio\_SetBlockLockingFlag( )}
\\
\href{#IsBlockLocked}{horatio\_IsBlockLocked( )}
\\
\href{#LockBlock}{horatio\_LockBlock( ) \& horatio\_UnlockBlock(
)}
\\
\href{#ToggleBlockLockingStatus}{horatio\_ToggleBlockLockingStatus(
)}
\\
\href{#EnableTraps}{horatio\_EnableTraps( )}
\\
\href{#DisableTraps}{horatio\_DisableTraps( )}
\\
\href{#AreTrapsEnabled}{horatio\_AreTrapsEnabled( )}
\\
\href{#GetStats}{horatio\_GetStats( )}
\\
\href{#GetBlockCount}{horatio\_GetBlockCount( )}
\\
\href{#Ver}{horatio\_Ver( )}
\\
\href{#Dump}{horatio\_Dump( )}

\par External variables
\\
\href{#\_EnableTraps}{horatio\_\_EnableTraps}
\\
\textbf{5.1~ Descriptions of all functions and their use}
\\
unsigned int horatio\_InstallDebugHook(const
unsigned short HookType, unsigned
int(*NewHookProc)(PS\_DPCRTLMM\_DEBUGHOOKINFO));
\\
Installs a new debug hook into the internal debug
hook chain, see \href{#Enumerations}{enumerations} for a
complete list of hook types.~ The
debug hook handler will accept a pointer to a structure full of
information
which will be of use for debugging, some of this information will be
debug
hook type dependant.~ If the hook is installed correctly the
function
returns 1 (true), if the hook is of a bad type or cannot be installed
the
return value is 0 (false).~ Your user defined hook routine should
take one of these actions, return 0U if you do not wish for other hooks
which follow you in the chain to be notified and called also, return 1U
if I may call following hooks.
\\
Do not call the library from your hook routine because this may
deadlock the library under threaded builds where mutual exclusion locks
do not support recursion.
\\
unsigned int
horatio\_GetDebugHookChainCount(const
unsigned int HookType);
\\
Returns the number of hooks installed for this
hook type, it is not valid to use DPCRTLMM\_HOOK\_ALL, for this
functionalliy
use \href{#GetDebugHookMatrixCount}{horatio\_GetDebugHookMatrixCount(
)}
\\
unsigned int
horatio\_GetDebugHookMatrixCount(void);
\\
Counts the number of hooks in the entire debug hook matrix, that is
the total number of hooks for all types, it is very unlikely that a
program
will have a practical use for this, I just thought I'd add it really,
plus
it has a cool name!
\\
unsigned int horatio\_UninstallDebugHook(const
unsigned short HookType, unsigned
int(*HookProc2Remove)(PS\_DPCRTLMM\_DEBUGHOOKINFO));
\\
Remove the said hook, type of hook should be specified in order to
find it, although the same hook handler can be installed for many
hooks,
so DPCRTLMM\_HOOK\_ALL is allowed.
\\
It's not allowed to uninstall hooks by index, the address of the hook
handler must be specified.~ On success 1 (true) is returned
otherwise
0 (false) is returned.
\\
void* horatio\_Alloc(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, const size\_t NewBlockSize);
\\
This function is the main allocation function, the equivillant to
malloc(
) in the C Run time library.~ It's prototype seems more complex
only
because of the block descriptor array.~ Block descriptor arrays
are
for organisation purposes, use \href{#CreateBlockArray}{horatio\_CreateBlockArray(
)} to get one before allocating any blocks of memory or specify NULL
to use the array provided by Horatio (the NULL array is not available
if the library is configured -$\,$-with-no-null-array).~ The size in
bytes of
the desired block should be specified.~ NULL is returned if the
block
cannot be allocated, check the log to make sure this is what caused the
error, any non-zero return is a pointer to the newly allocated block of
memory.~ Debug hooks installed and watching activities with this
event
will not see allocation requests unless they are valid, I'll fix this
by
the next version.
\\
void horatio\_Free(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, void* Ptr);
\\
This function is the main deallocation function, the equivilant to
free( ) in the C Run time library.~ The block descriptor array in
which the block was allocated must be specified, even if it is NULL,
which
represents the default internal library array, if the block did not
belong
to the array you specify a trap will be executed.~ If a debug hook
is installed on this type of event, remember that it must never
dereference
the PRelDesc field, the descriptor will have already been released.
\\
PS\_DPCRTLMM\_BLOCKDESCARRAY
horatio\_CreateBlockArray(void);
\\
Creates a new block descriptor array.~ A block descriptor array
is returned and should be kept.~ Then during allocations one can
use
the returned pointer in the first parameter.~ Don't forget to free
all blocks from an array and destroy it with \href{#DestroyBlockArray}{horatio\_DestroyBlockArray(
)} before the returned pointer goes out of scope.~ I recommend
each module, or each major section of a large project has it's own
block
descriptor array.~ I also recommend that the main module of the
program
and any shared memory should use the "NULL" block array, when \href{#Alloc}{horatio\_Alloc(
)} asks for a pointer to a block array just supply NULL to use
it.~
Hooking this event is allowed, hooks will be executed whether this
function
succeeds or fails, check the Success indicator of the debug hook info
your
hook is passed.
\\
void horatio\_DestroyBlockArray(
PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray );
\\
Destroys the said block descriptor array.~ NULL is \textbf{not}
allowed, the reason is NULL for a block descriptor array represents an
internal default array which the user is not allowed to destroy.~
If the pointer supplied is not in the internal safety list as a valid
block
array allocated by \href{#CreateBlockArray}{horatio\_CreateBlockArray(
)}, a trap will be executed.~ There is no return value.~
Hooks
will normally see both success and failure, check the Success entry of
the debug hook info.
\\
unsigned int horatio\_IsDefaultBlockArray(
PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray );
\\
In debug hooks and the like, the user may be returned a pointer which
does not corrospond to any of the pointers which were allocated, in
this
case it may be the resolved NULL pointer to the default array because
the
array is not directly available for comparison use this function to
determine
if that is the case, it will also report 1U (TRUE) for NULL since this
is the unresolved user version.~ Hooking this function is not
supported,
if you want it, call me.
\\
void horatio\_Startup(void);
\\
Before one calls any other functions in this library, the library must
be started, this allows various initialization tasks, there are
currently
no tests applied to ensure the library is started before any other
functions
are called, it's too time consuming as every function would have to
call
the test, the behaviour of the program calling the library before it is
started is undefined and could end in disaster.
\\
void horatio\_Shutdown(void);
\\
If one ends the program without shutting down the library the whole
point of this library becomes hidden, calling this function does not
just
allow internal library cleanup but will activate the search for unfreed
memory and is the point at which all the leaks will be revealed.~
I can't make sure the program writer calls this unfortunately, I would
recommend setting it up with atexit( ) as soon as the program to starts
just incase the program ends from somewhere other than main( ).~
Personally
I keep a routine called GlobalShutdown( ) or whatever in the main
module
of my programs which lists all global libraries to shutdown and global
memory to cleanup etc. and then just register that one function with
atexit(
), thus overcoming the 32 entry limit in atext( ).~ Also my
programs
contain GlobalStartup( ) which, as it's first function installs
GlobalShutdown(
) with atext( ) and then inits all the libraries, I then call
GlobalStartup(
) as the first thing to do in main( ) and then I don't have to worry
about
it.
\\
unsigned int horatio\_IsStarted(void);
\\
Version: 1.1.6
\\
This function returns nonzero if Horatio has been started.~ It
is intended to be used by libraries which rely on Horatio for
debugging
memory but need to know whether the program which uses it already uses
Horatio in oder to know when to start or stop the library or to leave
well alone.
\\
size\_t horatio\_GetBlockSize(
PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, void* BlockPtr);
\\
Returns the size of a block which one allocated earlier.~ The
address of the allocated block must be specified also.~ The size
will
be returned.
\\
unsigned int horatio\_IsBadBlockPtr(
PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, const void* BlockPtr);
\\
Normally calling a function in this library with invalid details will
cause a trap, this function is designed to test the validity of the
block
pointer within the block descriptor array.~ Calling this function
with an invalid array will still cause a trap but if BlockPtr is not
valid
for a valid block array (supplied) the function returns 1U (true),
meaning
"yes, this block ptr is bad".~ If the block is valid 0U (false) is
returned.~ To avoid a trap and test an array pointer call \href{#IsBadArrayPtr}{horatio\_IsBadArrayPtr(
)}
\\
unsigned int horatio\_IsBadArrayPtr(
PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray );
\\
Verifies the validity of a block descriptor array without causing a
trap, the return value is 1 (true) if the array pointer is bad, 0
(false)
for a good array pointer.~ NULL is accepted as a valid array
pointer,
so is the resolved version but it's unlikely you'll see that unless
your
code is a hook.
\\
void* horatio\_Realloc(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, void* OldBlockPtr, const size\_t NewSize);
\\
Reallocates a block, equivilant to C runtime library call realloc(
), this is used for resizing a block of memory.~ The block array
must
be specified, it can be NULL to specify the default array.~ The
pointer
to the block of memory to resize should be specified next, followed by
the desired new size.~ Attempting to resize to 0 is equivillant to
\href{#Free}{horatio\_Free(
)} I rely on your run-time library supporting this bahaviour
however,
in the next version I want to make sure it will work whether your
run-time
library supports it or not.~ The block of memory might be moved by
the operating system's memory manager the return value should be used
and
replaces OldBlockPtr which should now be considered invalid.~
Don't
replace your old pointer with the new one until you are sure it is
non-zero,
if it is NULL the block could not be resized, most probally because
there
is not enough continuous free memory.~ Note that NULL is also
returned
when a block is freed (providing your run-time library supports
it).~
If a debug hook is installed it will currently only see the event if
the
reallocation is successful, therefore the hook routine(s) will only see
Success = 1.
\\
void* horatio\_Calloc(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, const unsigned int N, const size\_t NewBlockSize);
\\
Equivilant to C run time library calloc( ) purely a wrapper around
alloc( N * NewBlockSize ) everything else is the same.~ See \href{#Alloc}{horatio\_Alloc(
)} for more information
\\
void horatio\_InstallTrapCallback(
void(*UserCallbackProc)(const
unsigned int TrapID, const char* TrapMessage), const unsigned int
AsHook
);
\\
When a trap is fired, the default behaviour of the program is to put
the message on stderr and call abort, this behaviour can be changed to
call (for example) the Daybo Logic fatal trap handler (which puts up a
blue screen), or something like that.~ The trap handler takes a
constant
pointer to a string (const char*), it should not return it should
always
terminate the program.~ Perhaps memory errors could be ignored by
not doing so but behaviour of the program afterwards might be
undefined.~
If the specified function is installed as a hook it is called when a
trap
is fired but if it returns the default library handler is called
anyway.~
It just gets a preview.~ Do not try to remove a handler by passing
NULL to this function, use \href{#RemoveTrapCallback}{horatio\_RemoveTrapCallback(
)}
\\
void horatio\_RemoveTrapCallback(
void(*CurrentCallbackProc)(const
unsigned int TrapID, const char* TrapDesc) );
\\
Removes a trap handler which was installed by \href{#InstallTrapCallback}{horatio\_InstallTrapHandler(
)}, must pass address so we know you know and are not making a
dreadful
mistake, there is no return value.
\\
signed char horatio\_GetTrapCallbackInfo(void);
\\
Sometimes the user of the library has installed a handler for traps
instead of the default library handler, the function returns very
simple
information about it.~ There are three possible values, the other
values won't be used.~ The three possible values are
\\
-1 for no user trap handler
\\
0 for a handler which is installed as a handler
\\
1 for a handler which acts as a hook.
\\
The important thing about a hook is that it gets preview of the trap
but the default one is called afterwards and therefore the hook is
expected
to return.~ A handler should terminate the program, if it returns
the default handler will not be called, the user handler has replaced
it.~
So if a handler returns the program may continue after a trap which
could
lead to unpredictable results.
\\
unsigned char
horatio\_ModifyDescriptorFlags(const
PS\_DPCRTLMM\_BLOCKDESCARRAY PBlockArray, const void* Ptr, const unsigned
char* PNewFlags);
\\
This function implements direct flag access (not reconmended except
for advanced programmers who have the library source so they know the
descriptor
flag meanings), casual programmers should use the specialist locking
functions
or other functions which change the flags but don't actually explictly
state that is what they are doing, this flag modifying function is
usually
used by the library internally and not by the users of the library, I
have
only made it available to the users because of the possibility of
unforeseen
circumstances arising, it's not very likely that users will need to use
this function.
\par Pass pointer to new flags for the block, old flags are returned, to
get the flags without modifying them, pass NULL as the
\\
pointer PNewFlags.~ It is feasible that the function could return
after a trap if traps are off or a user handler is called for the trap,
which returned.~ It is not possible to tell, if anything is
suspected
on running the program, at redesign your code so that it does not use a
user trap (just comment out the line installing the handler, or don't
turn
off trapping).
\\
void
horatio\_SetBlockLockingFlag(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, const void* Ptr, const unsigned int NewStatus);
\\
Locks or unlocks a block of memory.~ When a block of memory is
locked, it means it cannot be freed or resized, if a trap is fired as a
result of the call, the function \href{#ModifyDescriptorFlags}{ModifyDescriptorFlags(
)} is mentioned as the location of the trap, so don't get confused!
\\
NewStatus is a boolean, nonzero = true, zero = false.
\\
unsigned int
horatio\_IsBlockLocked(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, const void* Ptr);
\\
Simply returns the boolean status 1 if the block specified has been
locked or 0 if it has not.~ When a block is locked, it cannot be
freed
or resized.
\\
\#define horatio\_LockBlock(pArr, pBlock)
horatio\_SetBlockLockingFlag(pArr,
pBlock, (1U));
\\
\#define horatio\_UnlockBlock(pArr, pBlock)
horatio\_SetBlockLockingFlag(pArr,
pBlock, (0U));
\\
Both of these functions are simple macros to lock and unlock blocks
of memory see \href{#SetBlockLockingFlag}{horatio\_SetBlockLockingFlag(
)}
\\
void
horatio\_ToggleBlockLockingStatus(PS\_DPCRTLMM\_BLOCKDESCARRAY
PBlockArray, const void* Ptr);
\\
If the said block is locked, it will be unlocked and vice versa, not
sure if anyone will bother to use this function really
\\
void horatio\_EnableTraps(void);
\\
See \href{#DisableTraps}{horatio\_DisableTraps( )}, normally
only that will be used in a program for the reasons described.~
The
only reason one might want to use this function is for temporary things
say like, disable traps, perform actions, re-enable traps.~
Implemented
as a macro, see horatio\_\_EnableTraps
\\
void horatio\_DisableTraps(void);
\\
Normally when the library starts traps are enabled, however let's say
that the program is massive, a deadline is coming and it must be
released.~
Although there are a few leaks that can't be tracked down it's stable
and
users would have nothing to complain about.~ They won't be too
happy
if Horatio keeps outputting all the mistakes at the end.~
Removing
the library may not be feasible if the program is designed intimately
around
it so the answer is to disable the traps, just call this function once
after starting the library to avoid traps.~ Implemented as a
macro,
see horatio\_\_EnableTraps
\\
unsigned char horatio\_AreTrapsEnabled(void);
\\
Returns whether traps are enabled or not, 1U means enabled 0U if
not.~
Implemented as a macro, see \href{#_EnableTraps}{horatio\_\_EnableTraps}
\\
void horatio\_GetStats(PS\_DPCRTLMM\_STATS
PReadStats);
\\
Returns memory statistics for the library, such as, number of allocated
blocks, amount of memory used (charge) and peaks, pass a pointer to the
structure to read the data, forgetting to pass the pointer will do
absolutely
nothing.~ Most of the information can be returned directly from
internal
counts, most statistics are modified at the time they are changed, for
example allocating a block would increment the count of blocks and the
amount you added would be added to the total allocation charge.~
However,
because I made it possible to modify the flags of a descriptor I cannot
tell how many locks etc. there are, for these I had to implement a
nested
loop to check the flags of all descriptors, shouldn't reduce
performance
too much but remember that the function should not be called too often.
\\
unsigned long horatio\_GetBlockCount(void);
\\
Returns the number of blocks allocated, don't worry I'm not completely
mad, the count is stored internally it is not worked out by this
function,
I don't go mad, looping through all the arrays looking for blocks!
\\
PS\_DPCRTLMM\_VERSION
horatio\_Ver(PS\_DPCRTLMM\_VERSION
PVerStruct);
\\
Returns library version info, the caller supplies the structure and
I return them the same structure, passing NULL does nothing.
\\
void horatio\_Dump(FILE* Target);
\\
Dumps a listing of all allocated blocks of memory which are currently
managed by Horatio. Target may be any stream which allows writing, for
example stdout, stderr or a writable file. The output may be used for
knowing
what state memory is in at any time without having to wait until a trap
for a leak dump.
\\
extern unsigned char horatio\_\_EnableTraps;
\\
This can be used to disable/enable traps, while it is off no trap will
be executed and if the program makes a mistake it could crash, if can
either
be modified directly or with the macros \href{#EnableTraps}{horatio\_EnableTraps(
)}, \href{#DisableTraps}{horatio\_DisableTraps( )} and \href{#AreTrapsEnabled}{horatio\_AreTrapsEnabled(
)}.~ Generally one will want to switch it off when releasing a
program, simple start the program with a call to \href{#Startup}{horatio\_Startup(
)} and then set this variable to 0U, the two valid states are 0U =
no
traps, 1U = traps will be used.~ 1U is the default.~ If you
have
the absolutely version (source) this variable is store in horatio.c
\\
~

\par For the lastest news check the~ \href{http://www.daybologic.co.uk/dev/horatio}{web
page}~ and update your documentation \& library regularly,
remember
updates cost nothing.~ If you have an equiry of a more technical
nature
you can contact me directly at \href{http://www.daybologic.co.uk/mailddrp/}{\url{http://www.daybologic.co.uk/mailddrp/}}\href{mailto:palmer@overchat.org}{}


\par (C)Copyright 2000 -
\the\year
~David Duncan Ross Palmer, Daybo Logic. The library may only be used in accordance
with
the license, which can be ready by reading the COPYING file.\\


\end{document}
