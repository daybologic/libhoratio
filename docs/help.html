<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="David Duncan Ross Palmer">
  <meta name="GENERATOR"
 content="Mozilla/4.7 [en] (X11; I; Linux 2.2.17-0.6.1 ppc) [Netscape]">
  <meta name="Classification" content="programming,libraries">
  <meta name="Description"
 content="Technical documentation for the Horatio library">
  <meta name="KeyWords" content="DPCRTLMM,Memory manager,Daybo Logic,Horatio">
  <title>Daybo Logic Horatio documentation</title>
  <meta content="David Duncan Ross Palmer" name="author">
  <meta content="Manual for Horatio" name="description">
</head>
<body style="color: rgb(255, 255, 255); background-color: rgb(0, 0, 0);"
 alink="#c0ffc0" link="#ffff00" vlink="#c0c0c0">
<center><b><u><font size="+4">Daybo Logic's C memory management library
V1.2.0</font></u></b>
<br>
<b><u><font size="+4">technical documentation</font></u></b></center>
<p><b><u>Contents</u></b>
<br>
<a href="#About">1.&nbsp; About the library</a>
<br>
<a href="#Who">1.1&nbsp; So who are Daybo Logic?</a>
<br>
<a href="#Contact">1.2&nbsp; Contacting the author</a>
<br>
<a href="#FAQ">1.3&nbsp; FAQ</a>
<br>
<a href="#Compile">1.4&nbsp; Compiling the sources</a>
<br>
<a href="#Config">1.5&nbsp; Configuration options explained</a>
</p>
<p><a href="#Enumerations">2.0&nbsp; Enumerations and detail</a><br>
<a href="#Cost">2.1&nbsp; How much does it cost?</a>
<br>
<a href="#Platforms">2.2&nbsp; What platforms is the library available
for?</a>
</p>
<p><a href="#Concepts">3.0&nbsp; Concepts and structures used by the
library</a>
<br>
<a href="#Starting">3.1&nbsp; Getting started</a>
<br>
<a href="#Portability">3.2&nbsp; Portability issues</a>
<br>
<a href="#8086">3.3&nbsp; 8086 builds</a>
<br>
<a href="#PCH">3.4&nbsp; Precompiled headers</a>
</p>
<a href="#Plans">4.0&nbsp; Plans for next version</a>
</p>
<p><a href="#Listings">5.0&nbsp; Function listings</a>
<br>
<a href="#FuncDescs">5.1&nbsp; Descriptions of all functions and their
use</a>
<br>
</p>
<hr width="100%"><br>
<a name="About"></a><b><u>1.&nbsp; About the library</u></b>
<br>
This could be used as an alternative to
<br>
memory tracking tools such as CodeGuard of MemorySleuth,
<br>
it's not as thorough as them however, it can't detect memory over
<br>
runs on pointer accesses or anything like that.&nbsp; It can be used
<br>
to detect failures to release memory (as long as it's allocated
<br>
by us) and attempts to release memory which we do not own.
<br>
It has an automatic garbage collection feature to free up all
<br>
unfreed memory too.&nbsp; It should be used by the entire program to
<br>
be most effective, it can provide statistics on memory left and
<br>
such like too.&nbsp; The best thing about the MM is that it provides
<br>
a central place for dynamic memory allocation in a program, so
<br>
we can trace all activity, an optional log mode is available too.<br>
Swapping is not implemented but may be in a future version.<br>
If the program is going to be released even though
<br>
it contains memory bugs, the traps can be turned off or passed to
<br>
a handler which will only execute the serious ones.
<br>
<hr width="100%">
<br>
<a name="Who"></a><b><u>1.1&nbsp; So who are Daybo Logic?</u></b>
<br>
Daybo Logic started in 1997 as a software development company.&nbsp; It
then became a general troubleshooting company, as a sole trader, David
Duncan Ross Palmer and in 2006, it reverted to being purely a
programming hobby of mine.&nbsp; I still release all my software,
including source code on the Daybo Logic web-site at <a
 href="http://www.daybologic.co.uk/">www.daybologic.co.uk</a>.<br>
<hr width="100%">
<br>
<a name="Contact"></a><b><u>1.2&nbsp; Contacting the author</u></b>
<br>
The author of this library is David Duncan Ross Palmer, a C/C++
programmer
since 1997 and a BASIC programmer since 1989.&nbsp; Born 5th March 1982
and interested in computers since an early age.&nbsp; This product was
a side effect of wanting to be able trap memory errors on users
machines
during beta testing phase, it was not originally designed to be
released,
it was originally too dependant on other Daybo Logic internal
libraries.&nbsp;
It was then offered for download for free and a fee for the advanced
features.&nbsp;
Eventually the whole source was open sourced under the GNU General
Public
License.&nbsp; IN 2006, the library was re-released under a BSD-style
license.&nbsp; The author of the library can be conacted by visiting
the following web-site: <a href="http://www.daybologic.co.uk/mailddrp/">http://www.daybologic.co.uk/mailddrp/</a>.&nbsp;
I especially welcome bug reports, feature requests and technical
questions.<br>
<hr width="100%">
<br>
<a name="FAQ"></a><span
 style="font-weight: bold; text-decoration: underline;">1.3&nbsp; FAQ -
Frequently Asked Questions and common
compile problems</span>
<p>Q - I am using ./configure --enable-threads --with-gnu-pth to link
with the GNU Portable Threads library.&nbsp; As soon as my program
initialises the DPCRTLMM library, the program crashes with a
segmentation fault.&nbsp; Is this a bug?<br>
A - No, GNU Portable Threads needs explicit initialisation before
use.&nbsp; DPCRTLMM uses GNU Portable threads for an internal lock and
initialises this lock when DPCRTLMM is initialised.&nbsp; It is your
program's responsibility to initialise GNU Portable Threads before
DPCRTLMM is initialised.&nbsp; You will need to call pth_init( ) at
some point before <a href="#Startup">dpcrtlmm_Startup</a>( ) is called.<br>
</p>
<p>Q - Error dpcrtlmm.h (line number): Declaration missing ;
<br>
A - The following answer applies to 16-bit segmented programming
only.&nbsp; This only happens if you selected to have explict far data
for the 16-bit tiny, small
or medium memory models.&nbsp; The answer is one of these solutions I
hope,
firstly check the language is set to non-ANSI compliance, if your
compiler
only supports ANSI you cannot support explicit far pointers so give
up!&nbsp;
The other problem is on line 112 (ish) of BUILD.H #define
DPCRTLMM_FARDATA
_ _ far, change the _ _ far bit to just far and try again.&nbsp; Look
for
what the 'far' keyword equivilant is in your language.&nbsp; If you
still
have problems contact me.
</p>
<p>Q - No prototype for function 'farmalloc' or 'farcalloc' or
'farfree'
or 'farrealloc'
<br>
A - The following answer applies to 16-bit segmented programming
only.&nbsp; The explicit fars are non-ANSI, unfortunately the functions
differ
from one compiler to the next when one strays from ANSI.&nbsp; In
BUILD.H
there are a list of functions here, change them to point to your
compiler's
equivilant functions if you can discover what they are.&nbsp; If you
don't
have any you will have to give up and turn off this option, make sure
you
don't have strict ANSI C compliance on or anything first but if all
else
fails just compile for the compact/large or huge model.
</p>
<p>Q - I want to compile for 16-bit x86 processors in small memory
models.&nbsp; However, the pointers returned from DPCRTLMM use my
segment address and not real segment address,&nbsp; When I try to
success these pointers, the program crashes, or unexpected results
happen.<br>
A - The library only functions correctly with far data, run ./configure
with --enable-fardata to enable explicit support.&nbsp; Unfortunately,
this is not within the scope of ANSI C and you may find difficulty
compiling.&nbsp; If your compiler cannot support explicit far pointers,
you may be forced to compile for another memory model or not use
DPCRTLMM at all.<br>
</p>
<p>Q - My program is crashing unexpectedly when I try to free blocks of
memory (or earlier while using the memory manager)
<br>
A - The most common problem is forgetting to start the library, if
this is not the case and you are compiling for a 16-bit processor it
may
be that the data is near.&nbsp; The easiest way to avoid this is to
rebuild
in a memory model which has far data.&nbsp; There is another way in
this
version of the library, Configure with --enable-fardata.&nbsp; If this
does not solve
the problem please send me all details possible.
<br>
</p>
<hr width="100%"><br>
<a name="Compile"></a><b><u>1.4&nbsp; Compiling the sources</u></b>
<br>
<span style="color: rgb(204, 0, 0);">The way in which the library is
built can change from time to time,
last minute notes may be added in a file called README if these do not
work.</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">Compiling under UNIX:</span><br
 style="color: rgb(204, 0, 0);">
<br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">Unpack the souce tarball with the
following command:</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">tar -zxvf dpcrtlmm-1.2.0.tar.gz or</span><br
 style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">tar -jxvf dpcrtlmm-1.2.0.tar.bz2
if you are using the bzip2ed version.</span><br
 style="color: rgb(204, 0, 0);">
<br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">cd dpcrtlmm-1.2.0/</span><br
 style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">./configure --help</span><br
 style="color: rgb(204, 0, 0);">
<br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">This will display a large output
of help text.&nbsp; It may help to
pipe this though 'more'.&nbsp; Read this help carefully and when you
have decided upon the configuration options you want to use, type:</span><br
 style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">./configure [add any options you
want to use here]</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">Once the script has configured
(assuming all went well), type:</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">make.</span><br
 style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">This builds the library.</span><br
 style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">You can now type make check if you
want to build and run some
example/test programs.</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">Finally, as root, type make
install.</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);">The DPCRTLMM library is now
installed and ready for use by your system.</span><br>
<br>
Compiling under Win32 (Borland C):<br>
<span style="color: rgb(204, 0, 0);">(write these instructions)</span><br>
<br>
Compiling under Win32 (Microsoft C):<br>
<span style="color: rgb(204, 0, 0);">(write these instructions)</span><br>
<br>
Compiling under Win32 (Open Watcom C):<br>
<span style="color: rgb(204, 0, 0);">(write these instructions)</span><br>
<br>
Compiling under DOS (Turbo C):<br>
<span style="color: rgb(204, 0, 0);">First, you will need to have
either a Win32 or UNIX-like box available and have Perl
installed.&nbsp; Then run perl ./mkdosdist.pl<br>
This will update all of the of the source files in a sub-directory
called dos_dist/ and rename them to DOS compatible names.<br>
Finally, it will process each of the files multiple times to rename any
internal references to the old filenames (this may take some time).<br>
Warning: Do not run the mkdosdist.pl script if you have build the
sources under another OS because you will have your own<br>
config.h which will over-write the DOS-crafted one which is stored as
dos_dist/config.h.<br>
You now have a useable source for building with Turbo C.&nbsp; I have
also supplied project files which may or may not work for you.<br>
I built them from the directory c:\dpcrtlmm.&nbsp; If it works, you
might be able to get away with typing:<br>
tc /b dpcrtlmm.prj<br>
This will build dpcrtlmm.lib from the sources.&nbsp; You may need to
mess around with memory models and the contents of config.h<br>
to get things to work.&nbsp; I found that things generally worked only
if built with a large memory model.&nbsp; This is generally what you<br>
will need to do nowadays anyway, as people don't tend to explicitly use
far or near pointers any more.<br>
</span>
<hr width="100%"><br>
<a name="Config"></a><b><u>1.5&nbsp; Configuration options explained</u></b>
<br>
Since version 1.2.0, the old config program has been removed.&nbsp; It
has been replaced with a GNU autoconf generated configure script.&nbsp;
This is good news for the portability and maintenance of DPCRTMM on
UNIX platforms but it does means that pure DOS and Win32 users must
either run the script via Cygwin (Win32) only, or edit config.h
manually and then build their own makefile for their compiler.&nbsp;
However, I have decided that it is in the best interest of the project
because, although we do have DOS and Win32 users, the majority of the
library's users use a form of UNIX and UNIX is my development platform
for the library.<br>
./configure --help displays some help but if you're still stuck, these
explanations
should reveal some more detail and history.
<p>--enable-win32<br>
The configure script can't tell if you are running it under Cygwin and
indeed, you may still want to build for POSIX.&nbsp; Enabling this
switch turns on specific Win32 code.&nbsp; If you are building with
--enable-threads, it will use the Win32 API for mutual exclusion,
rather than the pthread (POSIX threads) API.<br>
</p>
<p>--enable-debug
<br>
This option defines DEBUG, it means extra debugging code is added to
DPCRTLMM for when I am debugging it, it does not add any extra
information
for debugging your programs, only to my code.&nbsp; This could cause
the
library to abort on assert( ) traps and such.&nbsp; If you want to help
submit problems with DPCRTLMM, make sure it's built with
--enable-debug.&nbsp;
This will also add symbolic debug information to DPCRTLMM where
possible.<br>
</p>
<p>--enable-threads
<br>
Enables multithread safety.&nbsp; Note: This does not inply support,
DPCRTLMM can't handle threads portably for logging purposes etc.&nbsp;
This option makes sure that DPCRTLMM is mutually exclusive, that is, if
two threads attempt to call the library at the same time, one will
succeed
and one will have to wait until the first finishes.&nbsp; This stops
internal
corruption of DPCRTLMM's data structures but adds overhead, don't use
it
if you don't use pre-emptive threads.&nbsp; This is supported only on
the
following platforms: POSIX, Win32.<br>
</p>
<p>--with-gnu-pth<br>
This will enable you to build against the GNU Portable Threads library,
rather than the POSIX threads API.&nbsp; This is useful if your program
uses the GNU Portable Threads rather than POSIX threads.&nbsp; You will
get a warning if you specifiy --enable-win32 and --with-gnu-pth because
at time of writing, The GNU Portable Threads are only supported on
UNIX-like platforms.&nbsp; Your program is resonsible for initialising
the GNU Portable Threads library before DPCRTLMM is started.<br>
</p>
<p>--enable-stderr
<br>
Error traffic will be printed onto stderr, a stream which can be
redirected separately from the normal standard output stream.<br>
</p>
<p>--with-hook-chain-size:nnnn
<br>
The default hook chain size is 32.&nbsp; In DPCRTLMM before it was
Open Sourced advanced debug hooks were only allowed in paid-for
versions.&nbsp;
to get rid of them set this to zero.&nbsp; Otherwise a debug matrix is
used, a matrix of chains of hooks.&nbsp; Callers may install hooks into
the matrix, up to nnnn hook per hooktype.&nbsp; For example, if
monitoring
allocation requests, only 32 (by default) hooks may be installed for
the
allocation type of hook.&nbsp; If one does not plan to use this
feature,
set this to zero to avoid space wastage.&nbsp; Being a matrix, a high
value will occupy a large amount of space quickly.&nbsp; The total size
used can be calculated by the hook chainsize, multiplied by the size of
a hook pointer, multiplied by the number of debuggable hook types (eg.
allocation is one specific type of debug hook).<br>
</p>
<p>--with-safety-list-size:nnnn
<br>
The default is 512.&nbsp; When creating new block arrays, each address
of a block array is stored in an internal "safety list".&nbsp; It's a
fixed
size array determined here.&nbsp; It may not be zero but may be in the
future.&nbsp; I recommend a new block array per module, so if the
program
contains 512 modules this is fine, otherwise adjust accordingly to save
space or provide more space.
</p>
<p>--enable-fardata
<br>
For tiny, small and compact memory models in 16-bit segmented systems
ONLY.&nbsp; This makes sure pointers are not truncated between callers
in modules using near pointers and the DPCRTLMM library in other
modules
using near pointers.&nbsp; This ensures the DPCRTLMM library explictly
uses far pointers and the host program's code knows it.&nbsp; Far
pointers are non-ANSI, therefore, if this doesn't work,
editing build.h might be necessary, see the <a href="#FAQ">FAQ</a>.&nbsp;
If you enable this option on 32-bit platforms, you will just break the
build.<br>
</p>
<p>--enable-hdrstop<br>
This will produce #pragma hdrstop and allow pre-defined header
stop-points for pre-processors which support it.&nbsp; It is harmless
and will just produce a warning for every file if it is not supported.<br>
</p>
<p>--with-no-null-array<br>
When I created the new NULL (default) array so that calls could be
made to <a href="#Alloc">dpcrtlmm_Alloc</a>( ) and other functions
without
specifying a block array, I realised that existing code might be broken
if it accidently failed to created a new block array and then used
it.&nbsp;
Therefore I have always kept up an effort to make sure that the new
NULL
array could be ignored and cause the same errors as before.&nbsp; This
really is for legacy support only.<br>
</p>
<p>--enable-log
<br>
A file called HORATIO.LOG wil be created and record the activity of
every library call.&nbsp; This is an alternative to installing debug
hooks.&nbsp; Do not forget to disable this feature before releasing
your program!&nbsp; HORATIO.LOG can grow very quickly!<br>
</p>
<hr width="100%"><br>
<a name="Enumerations"></a><b><u>2.0&nbsp; Enumerations and detail</u></b><br>
Blah<br>
<hr width="100%"><br>
<a name="Cost"></a><b><u>2.1&nbsp; How much does it cost?</u></b>
<br>
Nothing, but I do accept donations via the web-site.&nbsp; If you have
found this software useful, please donate.&nbsp; If you can't afford to
donate (which I wholly understand), please send me an email letting me
know what you are using the library with.&nbsp; I really would be
interested to know!&nbsp; I get quite a bit of email but I do enjoy
reading email from folk who are using my software.<br>
<hr width="100%">
<br>
<a name="Platforms"></a><b><u>2.2&nbsp; What platforms is the library
available for</u></b>
<br>
The library has been tested on the following platforms: Win16, Win32,
DOS (16-bit and 32-bit builds), GNU/Linux and FreeBSD.<br>
I aim to make sure this library can be built anywhere and if you have
any specfic problems building it, please let me know.<br>
<hr width="100%">
<br>
<a name="Concepts"></a><b><u>3.0&nbsp; Concepts and structures used
by the library</u></b>
<br>
The primary memory managment structure is called a block descriptor,
it contains basic information about a block of memory allocated by the
program, it is not normally directly accessed by a program, it is
generally
only used by the library, it is possible to access it but I don't know
why a program would need to because all information may be obtained
using
the library interface.
<p>These block descriptors contain this simple information: The block's
base address, size in bytes and a number of flags with special
meanings.
</p>
<p>The other structure you will encounter is the block descriptor
array.&nbsp;
I recommend that every C file maintains it's own array.&nbsp; When a
block
is allocated it's decriptor is always inserted into one of these arrays
and nearly every library call will want to know the address of one of
these
arrays.&nbsp; This only causes a problem if the program&nbsp; passes a
descriptor to another module the program which tries to get size
information
on the block using the library functions while passing it's own array,
then the program will be terminated because the library will assume
that
the address is invalid.&nbsp; I recommend using NULL as a placeholder
for
arrays, for blocks which are designed to be shared.&nbsp; Normal
sharing
is fine, as long as the library is not used on that block from another
module.&nbsp; Note: If you have configured the library
--with-no-null-arrays,&nbsp; it will not be possible to use NULL in
this manner.<br>
</p>
<p>The final structure is stored internally and the program should
never
need to access, this structure is called the safety list.&nbsp; It is a
large fixed size array of all the addresses of the block descriptor
arrays
used throughout the program.&nbsp; The interface to this list is kept
internal
to the library, if you want to access it you could always add it to
DPCRTLMM.H,
although there should be no reason to do this.&nbsp; The safety list's
size can be adjusted at configuration time via the
--with-safety-list-size option.<br>
</p>
<p>So what is this safety list for if I can't access it under normal
circumstances?&nbsp;
Well, it's used to trap any call to the library which specifies an
invalid
pointer to a block descriptor array.&nbsp; It is also processed when
the
library is shut down to ensure all blocks have been released, it is
therefore
is the primary structure for producing a leak report.
<br>
</p>
<hr width="100%"><br>
<a name="Starting"></a><b><u>3.1&nbsp; Getting started</u></b>
<br>
If you already have a program to convert to use the library I suggest
this.&nbsp; Download at least version 1.1.4 and define USING_HORATIO
before
including dpcrtlmm.h in each module.&nbsp; This makes malloc( ),
calloc( ), realloc( ) and free( ), call DPCRTLMM instead.&nbsp; Also,
since the library should
be started and shutdown correctly, I recommend code similar to example3
as a typical transparent usage program.
<p>If you are writing a new program use the library from the start, add
a block descriptor array structure to the main module at file level,
then
in main call the library startup routine, create the array then
allocate
blocks using it.&nbsp; When main() is about to exit free all blocks,
destroy
the array with the dedicated function and shutdown the library.&nbsp;
These
destroy and shutdown routines are the main ones which check if anything
was not freed from the array.<br>
</p>
<hr width="100%"><br>
<a name="Portability"></a><b><u>3.2&nbsp; Portablilty issues</u></b>
<br>
This library will slow the program down but not make it any less
portable
as such.&nbsp; However if you later want to speed the program up and
remove
the library read the section Getting Started, the first paragraph
describes
a hack, designing the program in the first place to use this hack is
the
only way to easily remove the library.&nbsp; Another approach might be
to write a dummy version of the library, only doing the bare minimum, I
intend to write one of these at some point soon.
<p>By default the library source is portable, it can be setup to use
some
non-ANSI features:
<br>
far pointers, mutexes and critical sections.&nbsp;
Most instructions for changes are in build.h, please use the configure
script
where appropriate.<br>
<br>
</p>
<hr width="100%"><br>
<a name="8086"></a><b><u>3.3&nbsp; 8086 builds</u></b>
<br>
When building the library for the 8086-80286 (16-bit versions of
Intel's
processor) the library should be built for one of these memory models:
Compact, Large or Huge.&nbsp; Trying to build the library for smaller
memory
models results in near data.&nbsp; If such a build is made I have
discovered
that the hosting program will be assuming the wrong data segment when
the
pointers are returned from the library.&nbsp; There is a way to get
around
this if you really want to use a smaller memory model, build with
--enable-fardata.&nbsp; This is non-ANSI and you're on your own if your
compiler can't support the '__far' keyword.<br>
<br>
<hr width="100%">
<br>
<a name="PCH"></a><b><u>3.4&nbsp; Precompiled headers</u></b>
<br>
My compiler (Borland C++) supports this pragma:
<br>
#pragma hdrstop
<br>
However using it on other compilers might cause a warning, to avoid
annoyance to people, it is disabled by default.&nbsp; To enable it,
re-configure with ./configure --enable-hdrstop.<br>
<hr width="100%"><br>
<a name="Plans"></a><b><u>4.0&nbsp; Plans for next version</u></b>
<br>
The internal debug hook executive seems to use a parameter which it
could get from the debug info structure passed to it, the hook type is
not used and is a waste.&nbsp; This does not affect callers of the
library,
since the debug hook executive cannot be called from outside.
<p>Swapping to disk should be implemented with an LRU algortihm, based
on the flag in block descriptor (unswappable, bit 1) and the block
descriptor
may have to be extended with more fields to support this.
</p>
<p>The library is a bit slow due to an excessive amount of calls to
_VerifyPtrs(
), which an internal routine called to check the user's pointers are
valid,
however it's also called when functions call other functions, even
though
they already know the pointers are safe, to avoid this I may make an
inner
shell, where the user calls safety wrappers around the real library and
all functions call the inner shell functions and not the entrypoints
the
users sees.
<br>
</p>
<hr width="100%"><br>
<a name="Listings"></a><b><u>5.0 Function listings</u></b>
<br>
No documentation is supplied or can be found that I have written for
the hidden functions which I believe it is not worth library users
trying
to access.&nbsp; The file DPCRTLMM.H contains most structures that will
be of any interest too.&nbsp; If you have the library source you can
read
all the other headers to discover the hidden interface if you are that
nosey.
<p><a href="#InstallDebugHook">dpcrtlmm_InstallDebugHook( )</a>
<br>
<a href="#GetDebugHookChainCount">dpcrtlmm_GetDebugHookChainCount(
)</a>
<br>
<a href="#GetDebugHookMatrixCount">dpcrtlmm_GetDebugHookMatrixCount(
)</a>
<br>
<a href="#UninstallDebugHook">dpcrtlmm_UninstallDebugHook( )</a>
<br>
<a href="#Alloc">dpcrtlmm_Alloc( )</a>
<br>
<a href="#Free">dpcrtlmm_Free( )</a>
<br>
<a href="#CreateBlockArray">dpcrtlmm_CreateBlockArray( )</a>
<br>
<a href="#DestroyBlockArray">dpcrtlmm_DestroyBlockArray( )</a>
<br>
<a href="#IsDefaultBlockArray">dpcrtlmm_IsDefaultBlockArray( )</a>
<br>
<a href="#Startup">dpcrtlmm_Startup( )</a>
<br>
<a href="#Shutdown">dpcrtlmm_Shutdown( )</a>
<br>
<a href="#IsStarted">dpcrtlmm_IsStarted( )</a>
<br>
<a href="#GetBlockSize">dpcrtlmm_GetBlockSize( )</a>
<br>
<a href="#IsBasBlockPtr">dpcrtlmm_IsBadBlockPtr( )</a>
<br>
<a href="#IsBadArrayPtr">dpcrtlmm_IsBadArrayPtr( )</a>
<br>
<a href="#Realloc">dpcrtlmm_Realloc( )</a>
<br>
<a href="#Calloc">dpcrtlmm_Calloc( )</a>
<br>
<a href="#InstallTrapCallback">dpcrtlmm_InstallTrapCallback( )</a>
<br>
<a href="#RemoveTrapCallback">dpcrtlmm_RemoveTrapCallback( )</a>
<br>
<a href="#GetTrapCallbackInfo">dpcrtlmm_GetTrapCallbackInfo( )</a>
<br>
<a href="#ModifyDescriptorFlags">dpcrtlmm_ModifyDescriptorFlags( )</a>
<br>
<a href="#SetBlockLockingFlag">dpcrtlmm_SetBlockLockingFlag( )</a>
<br>
<a href="#IsBlockLocked">dpcrtlmm_IsBlockLocked( )</a>
<br>
<a href="#LockBlock">dpcrtlmm_LockBlock( ) &amp; dpcrtlmm_UnlockBlock(
)</a>
<br>
<a href="#ToggleBlockLockingStatus">dpcrtlmm_ToggleBlockLockingStatus(
)</a>
<br>
<a href="#EnableTraps">dpcrtlmm_EnableTraps( )</a>
<br>
<a href="#DisableTraps">dpcrtlmm_DisableTraps( )</a>
<br>
<a href="#AreTrapsEnabled">dpcrtlmm_AreTrapsEnabled( )</a>
<br>
<a href="#GetStats">dpcrtlmm_GetStats( )</a>
<br>
<a href="#GetBlockCount">dpcrtlmm_GetBlockCount( )</a>
<br>
<a href="#Ver">dpcrtlmm_Ver( )</a>
<br>
<a href="#Dump">dpcrtlmm_Dump( )</a>
</p>
<p>External variables
<br>
<a href="#_EnableTraps">dpcrtlmm__EnableTraps</a>
<br>
</p>
<hr width="100%"><br>
<a name="FuncDescs"></a><b><u>5.1&nbsp; Descriptions of all functions
and their use</u></b>
<br>
<a name="InstallDebugHook"></a><br>
<font color="#3333ff">unsigned int dpcrtlmm_InstallDebugHook(const
unsigned short HookType, unsigned
int(*NewHookProc)(PS_DPCRTLMM_DEBUGHOOKINFO));</font>
<br>
<font color="#ffffff">Installs a new debug hook into the internal debug
hook chain, see <a href="#Enumerations">enumerations</a> for a
complete list of hook types.&nbsp; The
debug hook handler will accept a pointer to a structure full of
information
which will be of use for debugging, some of this information will be
debug
hook type dependant.&nbsp; If the hook is installed correctly the
function
returns 1 (true), if the hook is of a bad type or cannot be installed
the
return value is 0 (false).&nbsp; Your user defined hook routine should
take one of these actions, return 0U if you do not wish for other hooks
which follow you in the chain to be notified and called also, return 1U
if I may call following hooks.</font>
<br>
Do not call the library from your hook routine because this may
deadlock the library under threaded builds where mutual exclusion locks
do not support recursion.<br>
<a name="GetDebugHookChainCount"></a><br>
<font color="#3366ff">unsigned int
dpcrtlmm_GetDebugHookChainCount(const
unsigned int HookType);</font>
<br>
<font color="#ffffff">Returns the number of hooks installed for this
hook type, it is not valid to use DPCRTLMM_HOOK_ALL, for this
functionalliy
use <a href="#GetDebugHookMatrixCount">dpcrtlmm_GetDebugHookMatrixCount(
)</a></font>
<br>
<a name="GetDebugHookMatrixCount"></a><br>
<font color="#3366ff">unsigned int
dpcrtlmm_GetDebugHookMatrixCount(void);</font>
<br>
Counts the number of hooks in the entire debug hook matrix, that is
the total number of hooks for all types, it is very unlikely that a
program
will have a practical use for this, I just thought I'd add it really,
plus
it has a cool name!
<br>
<a name="UninstallDebugHook"></a><br>
<font color="#3366ff">unsigned int dpcrtlmm_UninstallDebugHook(const
unsigned short HookType, unsigned
int(*HookProc2Remove)(PS_DPCRTLMM_DEBUGHOOKINFO));</font>
<br>
Remove the said hook, type of hook should be specified in order to
find it, although the same hook handler can be installed for many
hooks,
so DPCRTLMM_HOOK_ALL is allowed.
<br>
It's not allowed to uninstall hooks by index, the address of the hook
handler must be specified.&nbsp; On success 1 (true) is returned
otherwise
0 (false) is returned.
<br>
<a name="Alloc"></a><br>
<font color="#3366ff">void* dpcrtlmm_Alloc(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, const size_t NewBlockSize);</font>
<br>
This function is the main allocation function, the equivillant to
malloc(
) in the C Run time library.&nbsp; It's prototype seems more complex
only
because of the block descriptor array.&nbsp; Block descriptor arrays
are
for organisation purposes, use <a href="#CreateBlockArray">dpcrtlmm_CreateBlockArray(
)</a> to get one before allocating any blocks of memory or specify NULL
to use the array provided by DPCRTLMM (the NULL array is not available
if the library is configured --with-no-null-array).&nbsp; The size in
bytes of
the desired block should be specified.&nbsp; NULL is returned if the
block
cannot be allocated, check the log to make sure this is what caused the
error, any non-zero return is a pointer to the newly allocated block of
memory.&nbsp; Debug hooks installed and watching activities with this
event
will not see allocation requests unless they are valid, I'll fix this
by
the next version.
<br>
<a name="Free"></a><br>
<font color="#3366ff">void dpcrtlmm_Free(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, void* Ptr);</font>
<br>
This function is the main deallocation function, the equivilant to
free( ) in the C Run time library.&nbsp; The block descriptor array in
which the block was allocated must be specified, even if it is NULL,
which
represents the default internal library array, if the block did not
belong
to the array you specify a trap will be executed.&nbsp; If a debug hook
is installed on this type of event, remember that it must never
dereference
the PRelDesc field, the descriptor will have already been released.
<br>
<a name="CreateBlockArray"></a><br>
<font color="#3366ff">PS_DPCRTLMM_BLOCKDESCARRAY
dpcrtlmm_CreateBlockArray(void);</font>
<br>
Creates a new block descriptor array.&nbsp; A block descriptor array
is returned and should be kept.&nbsp; Then during allocations one can
use
the returned pointer in the first parameter.&nbsp; Don't forget to free
all blocks from an array and destroy it with <a
 href="#DestroyBlockArray">dpcrtlmm_DestroyBlockArray(
)</a> before the returned pointer goes out of scope.&nbsp; I recommend
each module, or each major section of a large project has it's own
block
descriptor array.&nbsp; I also recommend that the main module of the
program
and any shared memory should use the "NULL" block array, when <a
 href="#Alloc">dpcrtlmm_Alloc(
)</a> asks for a pointer to a block array just supply NULL to use
it.&nbsp;
Hooking this event is allowed, hooks will be executed whether this
function
succeeds or fails, check the Success indicator of the debug hook info
your
hook is passed.
<br>
<a name="DestroyBlockArray"></a><br>
<font color="#3366ff">void dpcrtlmm_DestroyBlockArray(
PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray );</font>
<br>
Destroys the said block descriptor array.&nbsp; NULL is <b>not</b>
allowed, the reason is NULL for a block descriptor array represents an
internal default array which the user is not allowed to destroy.&nbsp;
If the pointer supplied is not in the internal safety list as a valid
block
array allocated by <a href="#CreateBlockArray">dpcrtlmm_CreateBlockArray(
)</a>, a trap will be executed.&nbsp; There is no return value.&nbsp;
Hooks
will normally see both success and failure, check the Success entry of
the debug hook info.
<br>
<a name="IsDefaultBlockArray"></a><br>
<font color="#3333ff">unsigned int dpcrtlmm_IsDefaultBlockArray(
PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray );</font>
<br>
In debug hooks and the like, the user may be returned a pointer which
does not corrospond to any of the pointers which were allocated, in
this
case it may be the resolved NULL pointer to the default array because
the
array is not directly available for comparison use this function to
determine
if that is the case, it will also report 1U (TRUE) for NULL since this
is the unresolved user version.&nbsp; Hooking this function is not
supported,
if you want it, call me.
<br>
<a name="Startup"></a><br>
<font color="#3366ff">void dpcrtlmm_Startup(void);</font>
<br>
Before one calls any other functions in this library, the library must
be started, this allows various initialization tasks, there are
currently
no tests applied to ensure the library is started before any other
functions
are called, it's too time consuming as every function would have to
call
the test, the behaviour of the program calling the library before it is
started is undefined and could end in disaster.
<br>
<a name="Shutdown"></a><br>
<font color="#3366ff">void dpcrtlmm_Shutdown(void);</font>
<br>
If one ends the program without shutting down the library the whole
point of this library becomes hidden, calling this function does not
just
allow internal library cleanup but will activate the search for unfreed
memory and is the point at which all the leaks will be revealed.&nbsp;
I can't make sure the program writer calls this unfortunately, I would
recommend setting it up with atexit( ) as soon as the program to starts
just incase the program ends from somewhere other than main( ).&nbsp;
Personally
I keep a routine called GlobalShutdown( ) or whatever in the main
module
of my programs which lists all global libraries to shutdown and global
memory to cleanup etc. and then just register that one function with
atexit(
), thus overcoming the 32 entry limit in atext( ).&nbsp; Also my
programs
contain GlobalStartup( ) which, as it's first function installs
GlobalShutdown(
) with atext( ) and then inits all the libraries, I then call
GlobalStartup(
) as the first thing to do in main( ) and then I don't have to worry
about
it.
<br>
<a name="IsStarted"></a><br>
<font color="#3333ff">unsigned int dpcrtlmm_IsStarted(void);</font>
<br>
Version: 1.1.6
<br>
This function returns nonzero if DPCRTLMM has been started.&nbsp; It
is intended to be used by libraries which rely on DPCRTLMM for
debugging
memory but need to know whether the program which uses it already uses
DPCRTLMM in oder to know when to start or stop the library or to leave
well alone.
<br>
<a name="GetBlockSize"></a><br>
<font color="#3366ff">size_t dpcrtlmm_GetBlockSize(
PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, void* BlockPtr);</font>
<br>
Returns the size of a block which one allocated earlier.&nbsp; The
address of the allocated block must be specified also.&nbsp; The size
will
be returned.
<br>
<a name="IsBasBlockPtr"></a><br>
<font color="#3366ff">unsigned int dpcrtlmm_IsBadBlockPtr(
PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, const void* BlockPtr);</font>
<br>
Normally calling a function in this library with invalid details will
cause a trap, this function is designed to test the validity of the
block
pointer within the block descriptor array.&nbsp; Calling this function
with an invalid array will still cause a trap but if BlockPtr is not
valid
for a valid block array (supplied) the function returns 1U (true),
meaning
"yes, this block ptr is bad".&nbsp; If the block is valid 0U (false) is
returned.&nbsp; To avoid a trap and test an array pointer call <a
 href="#IsBadArrayPtr">dpcrtlmm_IsBadArrayPtr(
)</a>
<br>
<a name="IsBadArrayPtr"></a><br>
<font color="#3366ff">unsigned int dpcrtlmm_IsBadArrayPtr(
PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray );</font>
<br>
Verifies the validity of a block descriptor array without causing a
trap, the return value is 1 (true) if the array pointer is bad, 0
(false)
for a good array pointer.&nbsp; NULL is accepted as a valid array
pointer,
so is the resolved version but it's unlikely you'll see that unless
your
code is a hook.
<br>
<a name="Realloc"></a><br>
<font color="#3366ff">void* dpcrtlmm_Realloc(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, void* OldBlockPtr, const size_t NewSize);</font>
<br>
Reallocates a block, equivilant to C runtime library call realloc(
), this is used for resizing a block of memory.&nbsp; The block array
must
be specified, it can be NULL to specify the default array.&nbsp; The
pointer
to the block of memory to resize should be specified next, followed by
the desired new size.&nbsp; Attempting to resize to 0 is equivillant to
<a href="#Free">dpcrtlmm_Free(
)</a> I rely on your run-time library supporting this bahaviour
however,
in the next version I want to make sure it will work whether your
run-time
library supports it or not.&nbsp; The block of memory might be moved by
the operating system's memory manager the return value should be used
and
replaces OldBlockPtr which should now be considered invalid.&nbsp;
Don't
replace your old pointer with the new one until you are sure it is
non-zero,
if it is NULL the block could not be resized, most probally because
there
is not enough continuous free memory.&nbsp; Note that NULL is also
returned
when a block is freed (providing your run-time library supports
it).&nbsp;
If a debug hook is installed it will currently only see the event if
the
reallocation is successful, therefore the hook routine(s) will only see
Success = 1.
<br>
<a name="Calloc"></a><br>
<font color="#3366ff">void* dpcrtlmm_Calloc(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, const unsigned int N, const size_t NewBlockSize);</font>
<br>
Equivilant to C run time library calloc( ) purely a wrapper around
alloc( N * NewBlockSize ) everything else is the same.&nbsp; See <a
 href="#Alloc">dpcrtlmm_Alloc(
)</a> for more information
<br>
<a name="InstallTrapCallback"></a><br>
<font color="#3366ff">void dpcrtlmm_InstallTrapCallback(
void(*UserCallbackProc)(const
unsigned int TrapID, const char* TrapMessage), const unsigned int
AsHook
);</font>
<br>
When a trap is fired, the default behaviour of the program is to put
the message on stderr and call abort, this behaviour can be changed to
call (for example) the Daybo Logic fatal trap handler (which puts up a
blue screen), or something like that.&nbsp; The trap handler takes a
constant
pointer to a string (const char*), it should not return it should
always
terminate the program.&nbsp; Perhaps memory errors could be ignored by
not doing so but behaviour of the program afterwards might be
undefined.&nbsp;
If the specified function is installed as a hook it is called when a
trap
is fired but if it returns the default library handler is called
anyway.&nbsp;
It just gets a preview.&nbsp; Do not try to remove a handler by passing
NULL to this function, use <a href="#RemoveTrapCallback">dpcrtlmm_RemoveTrapCallback(
)</a>
<br>
<a name="RemoveTrapCallback"></a><br>
<font color="#3366ff">void dpcrtlmm_RemoveTrapCallback(
void(*CurrentCallbackProc)(const
unsigned int TrapID, const char* TrapDesc) );</font>
<br>
Removes a trap handler which was installed by <a
 href="#InstallTrapCallback">dpcrtlmm_InstallTrapHandler(
)</a>, must pass address so we know you know and are not making a
dreadful
mistake, there is no return value.
<br>
<a name="GetTrapCallbackInfo"></a><br>
<font color="#3366ff">signed char dpcrtlmm_GetTrapCallbackInfo(void);</font>
<br>
Sometimes the user of the library has installed a handler for traps
instead of the default library handler, the function returns very
simple
information about it.&nbsp; There are three possible values, the other
values won't be used.&nbsp; The three possible values are
<br>
-1 for no user trap handler
<br>
0 for a handler which is installed as a handler
<br>
1 for a handler which acts as a hook.
<br>
The important thing about a hook is that it gets preview of the trap
but the default one is called afterwards and therefore the hook is
expected
to return.&nbsp; A handler should terminate the program, if it returns
the default handler will not be called, the user handler has replaced
it.&nbsp;
So if a handler returns the program may continue after a trap which
could
lead to unpredictable results.
<br>
<a name="ModifyDescriptorFlags"></a><br>
<font color="#3366ff">unsigned char
dpcrtlmm_ModifyDescriptorFlags(const
PS_DPCRTLMM_BLOCKDESCARRAY PBlockArray, const void* Ptr, const unsigned
char* PNewFlags);</font>
<br>
This function implements direct flag access (not reconmended except
for advanced programmers who have the library source so they know the
descriptor
flag meanings), casual programmers should use the specialist locking
functions
or other functions which change the flags but don't actually explictly
state that is what they are doing, this flag modifying function is
usually
used by the library internally and not by the users of the library, I
have
only made it available to the users because of the possibility of
unforeseen
circumstances arising, it's not very likely that users will need to use
this function.
<p>Pass pointer to new flags for the block, old flags are returned, to
get the flags without modifying them, pass NULL as the
<br>
pointer PNewFlags.&nbsp; It is feasible that the function could return
after a trap if traps are off or a user handler is called for the trap,
which returned.&nbsp; It is not possible to tell, if anything is
suspected
on running the program, at redesign your code so that it does not use a
user trap (just comment out the line installing the handler, or don't
turn
off trapping).
<br>
<a name="SetBlockLockingFlag"></a><br>
<font color="#3366ff">void
dpcrtlmm_SetBlockLockingFlag(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, const void* Ptr, const unsigned int NewStatus);</font>
<br>
Locks or unlocks a block of memory.&nbsp; When a block of memory is
locked, it means it cannot be freed or resized, if a trap is fired as a
result of the call, the function <a href="#ModifyDescriptorFlags">ModifyDescriptorFlags(
)</a> is mentioned as the location of the trap, so don't get confused!
<br>
NewStatus is a boolean, nonzero = true, zero = false.
<br>
<a name="IsBlockLocked"></a><br>
<font color="#3366ff">unsigned int
dpcrtlmm_IsBlockLocked(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, const void* Ptr);</font>
<br>
Simply returns the boolean status 1 if the block specified has been
locked or 0 if it has not.&nbsp; When a block is locked, it cannot be
freed
or resized.
<br>
<a name="LockBlock"></a><br>
<font color="#3366ff">#define dpcrtlmm_LockBlock(pArr, pBlock)
dpcrtlmm_SetBlockLockingFlag(pArr,
pBlock, (1U));</font>
<br>
<font color="#3366ff">#define dpcrtlmm_UnlockBlock(pArr, pBlock)
dpcrtlmm_SetBlockLockingFlag(pArr,
pBlock, (0U));</font>
<br>
Both of these functions are simple macros to lock and unlock blocks
of memory see <a href="#SetBlockLockingFlag">dpcrtlmm_SetBlockLockingFlag(
)</a>
<br>
<a name="ToggleBlockLockingStatus"></a><br>
<font color="#3366ff">void
dpcrtlmm_ToggleBlockLockingStatus(PS_DPCRTLMM_BLOCKDESCARRAY
PBlockArray, const void* Ptr);</font>
<br>
If the said block is locked, it will be unlocked and vice versa, not
sure if anyone will bother to use this function really
<br>
<a name="EnableTraps"></a><br>
<font color="#3366ff">void dpcrtlmm_EnableTraps(void);</font>
<br>
See <a href="#DisableTraps">dpcrtlmm_DisableTraps( )</a>, normally
only that will be used in a program for the reasons described.&nbsp;
The
only reason one might want to use this function is for temporary things
say like, disable traps, perform actions, re-enable traps.&nbsp;
Implemented
as a macro, see dpcrtlmm__EnableTraps
<br>
<a name="DisableTraps"></a><br>
<font color="#3333ff">void dpcrtlmm_DisableTraps(void);</font>
<br>
Normally when the library starts traps are enabled, however let's say
that the program is massive, a deadline is coming and it must be
released.&nbsp;
Although there are a few leaks that can't be tracked down it's stable
and
users would have nothing to complain about.&nbsp; They won't be too
happy
if DPCRTLMM keeps outputting all the mistakes at the end.&nbsp;
Removing
the library may not be feasible if the program is designed intimately
around
it so the answer is to disable the traps, just call this function once
after starting the library to avoid traps.&nbsp; Implemented as a
macro,
see dpcrtlmm__EnableTraps
<br>
<a name="AreTrapsEnabled"></a><br>
<font color="#3333ff">unsigned char dpcrtlmm_AreTrapsEnabled(void);</font>
<br>
Returns whether traps are enabled or not, 1U means enabled 0U if
not.&nbsp;
Implemented as a macro, see <a href="#_EnableTraps">dpcrtlmm__EnableTraps</a>
<br>
<a name="GetStats"></a><br>
<font color="#3333ff">void dpcrtlmm_GetStats(PS_DPCRTLMM_STATS
PReadStats);</font>
<br>
Returns memory statistics for the library, such as, number of allocated
blocks, amount of memory used (charge) and peaks, pass a pointer to the
structure to read the data, forgetting to pass the pointer will do
absolutely
nothing.&nbsp; Most of the information can be returned directly from
internal
counts, most statistics are modified at the time they are changed, for
example allocating a block would increment the count of blocks and the
amount you added would be added to the total allocation charge.&nbsp;
However,
because I made it possible to modify the flags of a descriptor I cannot
tell how many locks etc. there are, for these I had to implement a
nested
loop to check the flags of all descriptors, shouldn't reduce
performance
too much but remember that the function should not be called too often.
<br>
<a name="GetBlockCount"></a><br>
<font color="#3333ff">unsigned long dpcrtlmm_GetBlockCount(void);</font>
<br>
Returns the number of blocks allocated, don't worry I'm not completely
mad, the count is stored internally it is not worked out by this
function,
I don't go mad, looping through all the arrays looking for blocks!
<br>
<a name="Ver"></a><br>
<font color="#3333ff">PS_DPCRTLMM_VERSION
dpcrtlmm_Ver(PS_DPCRTLMM_VERSION
PVerStruct);</font>
<br>
Returns library version info, the caller supplies the structure and
I return them the same structure, passing NULL does nothing.
<br>
<a name="Dump"></a><br>
<font color="#3333ff">void dpcrtlmm_Dump(FILE* Target);</font>
<br>
Dumps a listing of all allocated blocks of memory which are currently
managed by DPCRTLMM. Target may be any stream which allows writing, for
example stdout, stderr or a writable file. The output may be used for
knowing
what state memory is in at any time without having to wait until a trap
for a leak dump.
<br>
<a name="_EnableTraps"></a><br>
<font color="#3333ff">extern unsigned char dpcrtlmm__EnableTraps;</font>
<br>
This can be used to disable/enable traps, while it is off no trap will
be executed and if the program makes a mistake it could crash, if can
either
be modified directly or with the macros <a href="#EnableTraps">dpcrtlmm_EnableTraps(
)</a>, <a href="#DisableTraps">dpcrtlmm_DisableTraps( )</a> and <a
 href="#AreTrapsEnabled">dpcrtlmm_AreTrapsEnabled(
)</a>.&nbsp; Generally one will want to switch it off when releasing a
program, simple start the program with a call to <a href="#Startup">dpcrtlmm_Startup(
)</a> and then set this variable to 0U, the two valid states are 0U =
no
traps, 1U = traps will be used.&nbsp; 1U is the default.&nbsp; If you
have
the absoluetely version (source) this variable is store in dpcrtlmm.c
<br>
&nbsp;
</p>
<p>For the lastest news check the&nbsp; <a
 href="http://www.daybologic.co.uk/dev/dpcrtlmm">web
page</a>&nbsp; and update your documentation &amp; library regularly,
remember
updates cost nothing.&nbsp; If you have an equiry of a more technical
nature
you can contact me directly at <a
 href="http://www.daybologic.co.uk/mailddrp/">http://www.daybologic.co.uk/mailddrp/</a><a
 href="mailto:palmer@overchat.org"></a>
</p>
<center>
<p><font color="#ff0000"><font size="-2">(C)Copyright 2000-2012 David
Duncan
Ross Palmer, Daybo Logic. The library may only be used in accordence
with
the license, which can be ready by reading the COPYING file.<br>
</font></font></p>
</center>
</body>
</html>
